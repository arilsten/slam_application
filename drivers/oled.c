#include <stdlib.h>

#include "nrf_delay.h"
#include "nrf_spi_mngr.h"
#include "nrf_gpio.h"

#include "oled.h"

#ifndef NRFX_SPIM_ENABLED
#error "Missing in sdk_config.h: NRFX_SPIM_ENABLED"
#endif

/**RESET pin*/
#define OLED_RESET_PIN			8
/**DATA/COMMAND pin*/
#define OLED_DC_PIN				9
/**SPI queue length*/
#define OLED_QUEUE_LENGTH		15
/**OLED instance*/
#define OLED_SPI_INSTANCE_ID	2

/**SPI instance*/
NRF_SPI_MNGR_DEF(m_nrf_spi_mngr, OLED_QUEUE_LENGTH, OLED_SPI_INSTANCE_ID);

static nrf_drv_spi_config_t const spi_config = {
	.sck_pin = 20,
	.mosi_pin = 19,
	.miso_pin = NRF_DRV_SPI_PIN_NOT_USED,
	.ss_pin = 22,
	.irq_priority = APP_IRQ_PRIORITY_LOWEST,
	.orc = 0xFF,
	.frequency = NRF_DRV_SPI_FREQ_1M,
	.mode = NRF_DRV_SPI_MODE_0,
	.bit_order = NRF_DRV_SPI_BIT_ORDER_MSB_FIRST
};

static uint8_t oled_buffer[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,
0xC0,0xC0,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,
0x00,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,
0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,
0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,
0xC0,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0xC0,0xC0,0xC0,
0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,
0xFB,0xFB,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xC3,0xC3,0xC3,0xC3,0xC3,0xFF,0xFF,0xFF,0xFF,
0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x03,0x03,0xFF,0xFF,0xFF,0xFF,0x03,0x03,0xFF,0xFF,
0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,
0xF3,0xF3,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x03,0x03,0x03,0x03,
0x03,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,
0xFF,0xF3,0xF3,0xF3,0xF3,0xF3,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3F,0x3F,0x3F,
0x3F,0x3F,0x00,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,
0x3E,0x00,0x00,0x3F,0x3F,0x3F,0x3F,0x03,0x03,0x03,0x03,0x03,0x3F,0x3F,0x3F,0x3F,
0x00,0x00,0x3F,0x3F,0x3F,0x3F,0x00,0x00,0x3F,0x3F,0x3F,0x3F,0x00,0x00,0x3F,0x3F,
0x3F,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x3F,0x3F,0x3F,0x3C,0x3C,0x3C,0x3C,
0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x00,0x00,0x3F,0x3F,0x3F,0x3F,0x3C,0x3C,0x3C,0x3C,
0x3C,0x3F,0x3F,0x3F,0x3F,0x00,0x00,0x3F,0x3F,0x3F,0x3F,0x00,0x00,0x3F,0x3F,0x3F,
0x3F,0x3C,0x3C,0x3C,0x3C,0x3C,0x3F,0x3F,0x3F,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

static uint8_t display_buffer[64 * 128 / 8]; // consider removing!

static uint8_t const oled_init_commands[] = {
	0xAE, // display off
	0xD5, // display clockdiv
	0x80, // suggested ratio
	0xA8, // set multiplex
	63, // LCD-height - 1
	0xD3, // set display offset
	0x00, // no offset
	0x40, // line #0
	0x8D, // chargepump
	0x14, // internal vcc generate high voltage?
	0x20, // memory mode
	0x00, // 0x0 act like ks0108??
	0xA1, // segremap?
	0xC8, // COM output scan direction
	0xDA, // set coms pin
	0x12, // coms pin?
	0x81, // set contrast
	0xCF, // internal vcc
	0xD9, // set precharge
	0xF1, // internal vcc
	0xDB, // setvcomdetect
	0x40, // vcomdetect?
	0xA4, // display all on resume
	0xA6, // normal display
	0x2E, // deactivate scroll
	0xAF // display on
};

static uint8_t const oled_display_commands[] = {
	0x21,	// col addr
	0,		// col start
	127,	// col end addr (127=rst)
	0x22,	// page addr
	0,		// page start addr
	7		// page end addr
};

/**
 * @brief Callback to SPI manager for setting D/C.
 */
static void cb_oled_set_command_cb(void * p_user_data)
{
    nrf_gpio_pin_clear(OLED_DC_PIN);
}

/**
 * @brief Callback to SPI manager for setting D/C.
 */
static void cb_oled_set_data_cb(void * p_user_data)
{
    nrf_gpio_pin_set(OLED_DC_PIN);
}

/**
 * @brief Function for initialization of OLED.
 *
 * Callback function for the nRF gfx/display driver/module.
 * Configures SPI manager, GPIO pins and transmits the initialization
 * commands. The commands are described in the data sheet of the OLED,
 * but for simplicity the same commands as Adafruit's
 * initialization routine is used.
 */
 extern bool shared_SPI_init;
 
ret_code_t oled_init(void) {
	ret_code_t err_code;
    err_code = nrf_spi_mngr_init(&m_nrf_spi_mngr, &spi_config);
	
	if (err_code == NRFX_ERROR_INVALID_STATE) {
		nrf_spi_mngr_uninit(&m_nrf_spi_mngr);
		err_code = nrf_spi_mngr_init(&m_nrf_spi_mngr, &spi_config);
		APP_ERROR_CHECK(err_code);
	}

    if (err_code == NRF_SUCCESS)
    {
        nrf_gpio_pin_dir_set(OLED_DC_PIN, NRF_GPIO_PIN_DIR_OUTPUT);
        nrf_gpio_pin_dir_set(OLED_RESET_PIN, NRF_GPIO_PIN_DIR_OUTPUT);
		
		nrf_delay_us(1000);
		nrf_gpio_pin_clear(OLED_RESET_PIN);
		nrf_delay_us(10000);
		nrf_gpio_pin_set(OLED_RESET_PIN);
        nrf_delay_ms(2);

        nrf_spi_mngr_transfer_t const transfers[] =
        {
            NRF_SPI_MNGR_TRANSFER(oled_init_commands, sizeof(oled_init_commands), NULL, 0)
        };
        err_code = nrf_spi_mngr_perform(&m_nrf_spi_mngr, NULL, transfers, ARRAY_SIZE(transfers), NULL);
    }
    return err_code;
}

void oled_uninit(void)
{
    nrf_spi_mngr_uninit(&m_nrf_spi_mngr);
}

/**
 * @brief Function for drawing a single pixel in buffer
 *
 * Callback function for the nRF gfx/display driver/module. Note that pixels
 * are drawn in buffer, and not directly to OLED.
 *
 * @param x     X-position of pixel.
 * @param y     Y-position of pixel.
 * @param color Color of pixel, black or white.
 */
void oled_draw_pixel(uint16_t x, uint16_t y, uint32_t color) {
	ASSERT(x < OLED_WIDTH);
    ASSERT(y < OLED_HEIGHT);
	
	if (color == 1)
		oled_buffer[x + (y/8)*OLED_WIDTH] |= (1 << (y&7));
	else
		// oled_buffer[x + (y/8)*OLED_WIDTH] |= (1 << (y&7));
		oled_buffer[x + (y/8)*OLED_WIDTH] &= ~(1 << (y&7));

	// write to correct position in buffer, ref algorithm on paper
}

/**
 * @brief Function for drawing a rectangle in buffer.
 *
 * Callback function for the nRF gfx/display driver/module. Note that pixels
 * are drawn in buffer, and not directly to OLED. Algorithm is taken from
 * Nordic Semiconductor's library.
 *
 * @param x      Start X-position, lower left corner.
 * @param y      Start Y-position, lower left corner.
 * @param width  Width of rectangle.
 * @param height Color of pixel, black or white.
 * @param color  Color of rectangle, black or white.
 */
void oled_draw_rectangle(uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint32_t color) {
	if ((x + width) >= OLED_WIDTH)
    {
        return;
    }
    if ((y + height) >= OLED_HEIGHT)
    {
        return;
    }
	
	for (uint8_t idx_y = y; idx_y < (y + height); idx_y++)
    {
        for (uint8_t idx_x = x; idx_x < (x + width); idx_x++)
        {
            oled_draw_pixel(idx_x, idx_y, color);
        }
    }
}

/**
 * @brief Function for outputting buffer to OLED.
 *
 * Callback function for the nRF gfx/display driver/module.
 */
void oled_display(void) {
	ret_code_t err_code;
	nrf_gpio_pin_clear(OLED_DC_PIN);
	nrf_delay_us(5);
	
	err_code = nrf_spi_mngr_init(&m_nrf_spi_mngr, &spi_config);
	
	if (err_code == NRFX_ERROR_INVALID_STATE) {
		nrf_spi_mngr_uninit(&m_nrf_spi_mngr);
		err_code = nrf_spi_mngr_init(&m_nrf_spi_mngr, &spi_config);
		APP_ERROR_CHECK(err_code);
	}
	
	static nrf_spi_mngr_transfer_t const oled_display_transfer[] = {
		NRF_SPI_MNGR_TRANSFER(oled_display_commands, sizeof(oled_display_commands),
			display_buffer, sizeof(display_buffer))
	};
	nrf_spi_mngr_perform(&m_nrf_spi_mngr, &spi_config, oled_display_transfer, 1, NULL);
	
	nrf_gpio_pin_set(OLED_DC_PIN);
	nrf_delay_us(5);
	
	static nrf_spi_mngr_transfer_t const transfer[] = {
		NRF_SPI_MNGR_TRANSFER(oled_buffer, 128, NULL, 0),
		NRF_SPI_MNGR_TRANSFER(oled_buffer+128, 128, NULL, 0),
		NRF_SPI_MNGR_TRANSFER(oled_buffer+256, 128, NULL, 0),
		NRF_SPI_MNGR_TRANSFER(oled_buffer+384, 128, NULL, 0),
		NRF_SPI_MNGR_TRANSFER(oled_buffer+512, 128, NULL, 0),
		NRF_SPI_MNGR_TRANSFER(oled_buffer+640, 128, NULL, 0),
		NRF_SPI_MNGR_TRANSFER(oled_buffer+768, 128, NULL, 0),
		NRF_SPI_MNGR_TRANSFER(oled_buffer+896, 128, NULL, 0),
	};
	
	nrf_spi_mngr_perform(&m_nrf_spi_mngr, &spi_config, transfer,
		sizeof(transfer)/sizeof(transfer[0]), NULL);
}

/**
 * @brief Function for clearing buffer.
 *
 * Callback function for the nRF gfx/display driver/module.
 */
void oled_clear(void) {
	memset((void *)oled_buffer, 0, sizeof(oled_buffer));
}

/**
 * @brief Function for setting rotation. (Not implemented).
 *
 * Callback function for the nRF gfx/display driver/module. Note that this
 * functions is optional, and unlikely to be useful in the SLAM project.
 * It is include here primarily as the nRF gfx library must be given a
 * callback function even if not used.
 */
void oled_dummy_rotation_set(nrf_lcd_rotation_t rotation) {
	// unnecessary
}

/**
 * @brief Function for inverting OLED. (Not implemented).
 *
 * Callback function for the nRF gfx/display driver/module. Note that this
 * functions is optional It is include here primarily as the nRF gfx library
 * must be given a callback function even if not used.
 */
void oled_invert(bool invert) {
	// OLED has built-in invert command
}